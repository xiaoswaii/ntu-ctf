[0x05] Casino

一開始先利用gdb去嘗試是否可以Win Game。利用checksec檢查是否有這隻程式的保護機制，發現到有開canary，NX和PIE都沒開，後來利用readelf的方式看到GOT的memory address附近有lottery的值，因為可以達到wingame。之後看到在seed的下面有一些沒有使用到的記憶體位置可以塞入shellcode，於是便先把shellcode在name需要輸入的時候塞進去。後來發現這樣可能無法通過age的filter，於是用先32個a蓋掉name和seed。再塞shellcode到0x602110的記憶體位置。

接下來就更改原本會指到system library記憶體，一開始想要更改的是printf，後來發現printf這個system library在更改以後還會需要使用，因此就去看puts這個system library的會jmp到的memory address是0x602020。於是嘗試去把原本應該是puts這個system library的memory address覆蓋成我shellcode的位置，因為程式上可以猜兩次，並且每次也可以選擇要重新猜過的號碼位置，透過輸入負數是可以走到guess之前的memory address，因為readint()只可以讀4個bytes，因為需要透過兩次重猜的輸入，才能覆蓋完8個bytes。因此我的執行流程是：

1. 先覆蓋掉name和seed的部分，再塞入shellcode
2. 在第一次重猜先用shellcode的記憶體位置蓋掉puts jmp到的記憶體位置的後4個bytes(0x602020), 再第二次猜的時候透過直接使用gdb看lottery的答案(前提是seed是要被輸入名字時蓋掉)，輸入正確答案（這樣才能執行到puts），再用重猜的輸入覆蓋掉(0x602020)的前4個bytes